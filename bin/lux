#!/usr/bin/env escript
%% This is an -*- erlang -*- file.
%%! -sasl sasl_error_logger false

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Copyright 2012-2020 Tail-f Systems AB
%%
%% See the file "LICENSE" for information on usage and redistribution
%% of this file, and for a DISCLAIMER OF ALL WARRANTIES.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

-module(lux_main).
-mode(compile).
-compile(warnings_as_errors).

-export([
         start_trace/3,
         stop_trace/0,
         drop_prefix/1, drop_prefix/2,
         normalize_filename/1,
         split/2,
         has_timestamp/0,
         timestamp/0
        ]).

-define(APPLICATION, lux).
-define(FILES, "--").

-ifdef(OTP_RELEASE).
    -define(stacktrace(),
            fun() -> try throw(1) catch _:_:StAcK -> StAcK end end()).
    -define(CATCH_STACKTRACE(Class, Reason, Stacktrace),
            Class:Reason:Stacktrace ->
           ).
-else.
    -define(stacktrace(),
            try throw(1) catch _:_ -> erlang:get_stacktrace() end).
    -define(CATCH_STACKTRACE(Class, Reason, Stacktrace),
            Class:Reason ->
                Stacktrace = erlang:get_stacktrace(),
           ).
-endif.

-spec(main([string()]) -> no_return()).
main(OrigArgs) ->
    ExitCode =
        try
            case OrigArgs of
                ["--make" = Op] ->
                    make(Op);
                _ ->
                    ensure_lux_app_dir(true),
                    LuxAppDir = require_app(undefined, ?APPLICATION),
                    OpModes = ["--internal_debug", "--suite_trace",
                               "--display_trace", "--event_trace",
                               "--help", "--version", "--install",
                               "--annotate", "--history",
                               "--reltool", "--xref",
                               "--gen_markdown", "--pre_markdown"],
                    Args  = expand_flags(OrigArgs, OpModes),
                    Specs = specs(),
                    Opts  = getopts(Args, Specs, LuxAppDir),
                    %% io:format("Args: ~p\n", [Opts]),
                    dispatch(Opts, LuxAppDir, OpModes, Specs, OrigArgs)
            end
        catch
            ?CATCH_STACKTRACE(Class, Reason, EST)
                io:format("\n\nFATAL ERROR: ~p:~p\n\t~p\n",
                          [Class, Reason, EST]),
                2
        end,
    safe_halt(ExitCode).

dispatch([{files, Files}, {prev_log_dir, PrevLogDir} | Opts],
         _LuxAppDir, _OpModes, _Specs, OrigArgs) ->
    run(Opts, Files, PrevLogDir, OrigArgs);
dispatch(Opts, LuxAppDir, OpModes, Specs, OrigArgs) ->
    case select_op(Opts, OpModes) of
        {Op, Args} ->
            do_dispatch(Op, Opts, LuxAppDir, OpModes, Specs, Args, OrigArgs);
        undefined ->
            case add_defaults(Opts) of
                {ok, [{files, Files}, {prev_log_dir, PrevLogDir} | Opts2]} ->
                    run(Opts2, Files, PrevLogDir, OrigArgs);
                {error, Format, Args} ->
                    io:format(Format, Args),
                    1
            end
    end.

do_dispatch(Op, Opts, LuxAppDir, OpModes, Specs, Args, OrigArgs) ->
    case {Op, Args} of
        {"--help", [HelpMode]}      -> help(LuxAppDir, Specs, HelpMode);
        {"--version", [_]}          -> version();
        {"--gen_markdown", [File]}  -> gen_markdown(File);
        {"--pre_markdown", [File]}  -> pre_markdown(LuxAppDir, File);
        {"--internal_debug", [_]}   -> internal_debug(Op, OrigArgs);
        {"--event_trace", [_]}      -> event_trace(Op, LuxAppDir, Opts,
                                                   OpModes, Specs, OrigArgs);
        {"--suite_trace", [_]}      -> suite_trace(Op, LuxAppDir, Opts,
                                                   OpModes, Specs, OrigArgs);
        {"--display_trace", [File]} -> display_trace(LuxAppDir, File, Opts);
        {"--install", [InstallDir]} -> install(Op, LuxAppDir, InstallDir, Opts);
        {"--reltool", [_]}          -> reltool(Op, LuxAppDir, Opts);
        {"--xref", [_]}             -> xref(Op, LuxAppDir, Opts);
        {"--annotate", [LogFile]}   -> annotate(LogFile, Opts);
        {"--history", [LogDir]}     -> history(LogDir, Opts);
        _                           -> usage(Specs, LuxAppDir)
    end.

expand_flags(Args, OpModes) ->
    case Args of
        [First | _] ->
            case lists:member(First, OpModes) of
                true  -> Args; % Ignore additional flags for aux commands
                false -> do_expand_flags(Args)
            end;
        [] ->
            do_expand_flags(Args)
    end.

do_expand_flags(Args) ->
   env_to_args("LUX_FLAGS") ++ env_to_args("LUX_SYSTEM_FLAGS") ++ Args.

env_to_args(Var) ->
    case os:getenv(Var) of
        false -> [];
        Flags -> string:tokens(Flags, " ")
    end.

select_op(Opts, [Key | Keys]) ->
    case proplists:get_value(Key, Opts) of
        [] ->
            select_op(Opts, Keys);
        Vals ->
            {Key, Vals}
    end;
select_op(_Opts, []) ->
    undefined.

specs() ->
    [
     {"-h",                   ["--help=usage"]},
     {"-r",                   ["--rerun=fail"]},
     {"-c",                   ["--progress=compact"]},
     {"-v",                   ["--progress=verbose"]},
     {"-V",                   ["--progress=etrace"]},
     {"-VV",                  ["--progress=ctrace"]},
     {"-t",                   ["--progress=silent", "--tap=stdout"]},
     {"-d",                   ["--debug"]},
     {"-D",                   ["--internal_debug"]},
     {"-E",                   ["--event_trace"]},
     {"-T",                   ["--suite_trace"]},
     {?FILES,                 "",          string,                 mandatory},
     {"--help",               usage,       {enum, help},           optional},
     {"--version",            false,       boolean,                none},
     {"--gen_markdown",       undefined,   string,                 mandatory},
     {"--pre_markdown",       undefined,   string,                 mandatory},
     {"--internal_debug",     false,       boolean,                none},
     {"--event_trace",        false,       boolean,                none},
     {"--suite_trace",        false,       boolean,                none},
     {"--display_trace",      undefined,   string,                 mandatory},
     {"--filter_trace",       undefined,   string,                 mandatory},
     {"--install",            "",          string,                 optional},
     {"--install_app",        undefined,   string,                 mandatory},
     {"--install_profile",    standalone,  {enum, profile},        mandatory},
     {"--reltool",            false,       boolean,                none},
     {"--xref",               false,       boolean,                none},
     {"--annotate",           false,       string,                 mandatory},
     {"--history",            false,       string,                 mandatory},
     {"--rerun",              enable,      {enum, prio},           mandatory},
     {"--html",               enable,      {enum, html},           mandatory},
     {"--debug",              false,       boolean,                none},
     {"--debug_file",         undefined,   string,                 mandatory},
     {"--skip",               undefined,   string,                 mandatory},
     {"--skip_unless",        undefined,   string,                 mandatory},
     {"--skip_unstable",      false,       boolean,                none},
     {"--skip_skip",          false,       boolean,                none},
     {"--require",            undefined,   string,                 mandatory},
     {"--case_prefix",        undefined,   string,                 mandatory},
     {"--log_dir",            undefined,   string,                 mandatory},
     {"--config_dir",         undefined,   string,                 mandatory},
     {"--config_name",        undefined,   string,                 mandatory},
     {"--suite",              undefined,   string,                 mandatory},
     {"--run",                undefined,   string,                 mandatory},
     {"--extend_run",         false,       boolean,                none},
     {"--revision",           undefined,   string,                 mandatory},
     {"--hostname",           undefined,   string,                 mandatory},
     {"--mode",               execute,     {enum, mode},           mandatory},
     {"--doc",                infinity,    {integer, 0, infinity}, optional},
     {"--progress",           brief,       {enum, progress},       mandatory},
     {"--multiplier",         1000,        {integer, 0, infinity}, mandatory},
     {"--suite_timeout",      infinity,    {integer, 0, infinity}, mandatory},
     {"--case_timeout",       5*60*1000,   {integer, 0, infinity}, mandatory},
     {"--flush_timeout",      1000,        {integer, 0, infinity}, mandatory},
     {"--poll_timeout",       100,         {integer, 0, infinity}, mandatory},
     {"--timeout",            10*1000,     {integer, 0, infinity}, mandatory},
     {"--cleanup_timeout",    100*1000,    {integer, 0, infinity}, mandatory},
     {"--newshell"     ,      false,       boolean,                none},
     {"--shell_wrapper",      "",          string,                 optional},
     {"--shell_cmd",          "/bin/sh",   string,                 mandatory},
     {"--shell_args",         ["-i"],      string,                 mandatory},
     {"--shell_prompt_cmd",   "export PS1=SH-PROMPT:",
                                           string,                 mandatory},
     {"--shell_prompt_regexp","^SH-PROMPT:",
                                           string,                 mandatory},
     {"--post_cleanup_cmd",   undefined,   string,                 optional},
     {"--file_pattern", ".*\.lux" ++ [$$], string,                 mandatory},
     {"--root_dir",           undefined,   string,                 mandatory},
     {"--var",                undefined,   string,                 mandatory},
     {"--tap",                undefined,   string,                 mandatory},
     {"--junit",              false,       boolean,                none}
    ].

enum(profile) ->
    [standalone, development, embedded];
enum(mode) ->
    [list, list_dir, doc, validate, dump, execute];
enum(prio) ->
    [enable, success, skip, warning, fail, error, disable];
enum(html) ->
    [validate | enum(prio)];
enum(progress) ->
    [silent, summary, brief, doc, compact, verbose, etrace, ctrace];
enum(help) ->
    [usage, info, app_dir].

enum_usage(Enum) ->
    Atoms = enum(Enum),
    Strings = [atom_to_list(A) || A <- Atoms],
    "enum(" ++ string:join(Strings, "|") ++ ")".

enum_value(Enum, Val) when is_list(Val) ->
    enum_value(Enum, list_to_atom(Val));
enum_value(Enum, Val) when is_atom(Val) ->
    Vals = enum(Enum),
    case lists:member(Val, Vals) of
        true  -> Val;
        false -> badarg(Val, Enum)
    end.

add_defaults(Opts) ->
    case lists:keymember(files, 1, Opts) of
        true ->
            Opts;
        false ->
            {Files, Opts2} = translate_opts(Opts),
            do_add_defaults(Files, Opts2)
    end.

do_add_defaults(Files, Opts) ->
    UserRun = proplists:get_value(run, Opts),
    UserLogDir = proplists:get_value(log_dir, Opts),
    UserExtendRun = proplists:get_value(extend_run, Opts),
    case UserExtendRun of
        undefined -> ExtendRun = false;
        ExtendRun -> ok
    end,
    StartTime = timestamp(),
    UniqStr = uniq_str(StartTime),
    UniqRun = "run_" ++ UniqStr,
    Run =
        case UserRun of
            undefined -> UniqRun;
            UserRun   -> UserRun
        end,
    case UserLogDir of
        undefined -> RelLogDir = filename:join(["lux_logs", UniqRun]);
        RelLogDir -> ok
    end,
    AbsLogDir0 = normalize_filename(RelLogDir),
    ParentDir0 = filename:dirname(AbsLogDir0),
    Link0 = filename:join([ParentDir0, "latest_run"]),
    PrevLogDir =
        case file:read_link(Link0) of
            {ok, LinkTo} ->
                %% Reuse old log dir
                normalize_filename(filename:join([ParentDir0, LinkTo]));
            {error, _} ->
                undefined
        end,
    AbsLogDir =
        if
            UserLogDir =:= undefined, ExtendRun ->
                if
                    PrevLogDir =:= undefined ->
                        AbsLogDir0;
                    true ->
                        PrevLogDir
                end;
            true ->
                AbsLogDir0
        end,
    LogBase = "lux_summary.log",
    SummaryLog = filename:join([AbsLogDir, LogBase]),
    MoreOpts =
        [
         {start_time, StartTime},
         {run, Run},
         {log_dir, AbsLogDir}
        ],
    Replace = fun({Tag, _Val} = Opt, Acc) ->
                      lists:keystore(Tag, 1, Acc, Opt)
              end,
    Opts2 = lists:foldl(Replace, Opts, MoreOpts),
    Opts3 = [{files, Files}, {prev_log_dir, PrevLogDir} | Opts2],
    case lists:keyfind(mode, 1, Opts) of
        {_, M} when M =:= list orelse
                    M =:= list_dir orelse
                    M =:= doc orelse
                    M =:= dump ->
            {ok, Opts3};
        _M ->
            case opt_ensure_dir(ExtendRun, SummaryLog) of
                ok ->
                    opt_create_latest_link(UserLogDir, AbsLogDir),
                    {ok, Opts3};
                summary_log_exists ->
                    {error,
                     "ERROR: Summary log file already exists: ~s\n",
                     [SummaryLog]};
                {error, FileReason} ->
                    {error,
                     "ERROR: Failed to create log directory: ~s -> ~s\n",
                     [AbsLogDir, file:format_error(FileReason)]}
            end
    end.

has_timestamp() ->
    erlang:function_exported(erlang, timestamp, 0).

timestamp() ->
    case has_timestamp() of
        true  -> hidden_apply(erlang, timestamp, []); % Avoid xref warning
        false -> hidden_apply(erlang, now, [])        % Avoid compiler warning
    end.

hidden_apply(M, F, A) ->
    Obfuscated = fun() -> M end(),
    apply(Obfuscated, F, A).

uniq_str({_MegaSecs, _Secs, MicroSecs} = Now) ->
    {{Year, Month, Day}, {Hour, Min, Sec}} =
        calendar:now_to_universal_time(Now),
    lists:concat([Year, "_", r2(Month), "_", r2(Day), "_",
                  r2(Hour), "_", r2(Min), "_", r2(Sec), "_",
                  integer_to_list(MicroSecs)]).

r2(Int) when is_integer(Int) ->
    r2(integer_to_list(Int));
r2(String) when is_list(String) ->
    string:right(String, 2, $0).

drop_prefix(File) ->
    {ok, Cwd} = file:get_cwd(),
    drop_prefix(Cwd, File).

drop_prefix(Prefix, File) when is_binary(Prefix), is_binary(File) ->
    list_to_binary(drop_prefix(binary_to_list(Prefix), binary_to_list(File)));
drop_prefix(Prefix, File) when is_list(Prefix), is_list(File) ->
    SplitPrefix = filename:split(Prefix),
    SplitFile = filename:split(File),
    do_drop_prefix(SplitPrefix, SplitFile, SplitPrefix, File).

do_drop_prefix([H | Prefix], [H | File], OrigPrefix, OrigFile) ->
    do_drop_prefix(Prefix, File, OrigPrefix, OrigFile);
do_drop_prefix([], [], _OrigPrefix, _OrigFile) ->
    ".";
do_drop_prefix([], Rest, _OrigPrefix, _OrigFile) ->
    filename:join(Rest);
do_drop_prefix(DownPrefix, Rest, OrigPrefix, _OrigFile)
  when DownPrefix =/= OrigPrefix ->
    UpPrefix = lists:duplicate(length(DownPrefix), ".."),
    filename:join(UpPrefix ++ Rest);
do_drop_prefix(_DownPrefix, _Rest, _OrigPrefix, OrigFile) ->
    OrigFile.

normalize_filename(File) when is_binary(File) ->
    list_to_binary(normalize_filename(binary_to_list(File)));
normalize_filename(File) when is_list(File) ->
    Delim = "://",
    case split(File, Delim) of
        {Prefix, Rel} ->
            Delim2 = Delim,
            Abs = Rel;
        false ->
            Prefix = "",
            Delim2 = "",
            Abs = filename:absname(File)
    end,
    File2 = do_normalize_filename(filename:split(Abs), []),
    Prefix ++ Delim2 ++ File2.

do_normalize_filename([H|T], Acc) ->
    Acc2 =
        case H of
            "."                  -> Acc;
            ".." when Acc =:= [] -> Acc;
            ".."                 -> tl(Acc);
            _                    -> [H|Acc]
        end,
    do_normalize_filename(T, Acc2);
do_normalize_filename([], Acc) ->
    filename:join(lists:reverse(Acc)).

split(File, Delim) when is_binary(File), is_binary(Delim) ->
    case split(binary_to_list(File), binary_to_list(Delim)) of
        false ->
            false;
        {Before, After} ->
            {list_to_binary(Before), list_to_binary(After)}
    end;
split(File, Delim) when is_list(File), is_list(Delim) ->
    split2(File, Delim, Delim, [], 0).

split2([H|T], [H|DT], OrigDelim, Acc, N) ->
    %% Partial match delim
    split2(T, DT, OrigDelim, [H|Acc], N+1);
split2(Rest, [], _OrigDelim, Acc, N) ->
    %% Full match delim
    {lists:reverse(lists:nthtail(N, Acc)), Rest};
split2([H|T], _Delim, OrigDelim, Acc, _N) ->
    %% Reset delim
    split2(T, OrigDelim, OrigDelim, [H|Acc], 0);
split2([], _Delim, _OrigDelim, _Acc, _N) ->
    false.

opt_ensure_dir(ExtendRun, SummaryLog) ->
    case not ExtendRun andalso filelib:is_dir(SummaryLog) of
        true  -> summary_log_exists;
        false -> filelib:ensure_dir(SummaryLog)
    end.

opt_create_latest_link(undefined, AbsLogDir) ->
    ParentDir = filename:dirname(AbsLogDir),
    Link = filename:join([ParentDir, "latest_run"]),
    Base = filename:basename(AbsLogDir),
    _ = file:delete(Link),
    _ = file:make_symlink(Base, Link),
    ok;
opt_create_latest_link(_UserLogDir, _AbsLogDir) ->
    ok.

usage(Specs, LuxAppDir) ->
    do_usage(Specs, LuxAppDir, usage),
    1.

do_usage(Specs0, LuxAppDir, usage) ->
    Specs = [{"--make", false, boolean, none}] ++ Specs0,
    io:format("usage: ~s [OPTION]... [FILE]...\n", [script_base_name()]),
    P = fun(Atom) -> [H | T] = atom_to_list(Atom), [string:to_upper(H) | T] end,
    PrettyType = fun(Type) ->
                         case Type of
                             {enum, Enum}    -> enum_usage(Enum);
                             {T, _Min, _Max} -> P(T);
                             T               -> P(T)
                         end
                 end,
    Pretty = fun(Spec) ->
                     case Spec of
                         {Short, Opts} -> % alias
                             Long = lists:flatten([[O, " "] || O <- Opts]),
                             io:format("\t~s short for ~s\n", [Short, Long]);
                         {Name, _Default, Type, mandatory} ->
                             io:format("\t~s ~s\n", [Name, PrettyType(Type)]);
                         {Name, _Default, Type, optional} ->
                             io:format("\t~s [~s]\n", [Name, PrettyType(Type)]);
                         {Name, _Default, _Type, none} ->
                             io:format("\t~s\n", [Name])
                     end
             end,
    [Pretty(S) || S <- Specs, element(1, S) =/= ?FILES],
    info_doc(LuxAppDir);
do_usage(_Specs, _LuxAppDir, info) ->
    display_app_info();
do_usage(_Specs, LuxAppDir, app_dir) ->
    io:format("~s\n", [LuxAppDir]).

info_doc(LuxAppDir) ->
    DefaultDir = filename:join([LuxAppDir, "priv", "luxcfg"]),
    io:format("\nThe site default configuration file is located here:"
              "\n\n\t ~s\n",
              [DefaultDir]),
    ExampDir = filename:join([LuxAppDir, "examples"]),
    case filelib:is_dir(ExampDir) of
        true ->
            io:format("\nThe examples are installed here:"
                      "\n\n\t ~s\n",
                      [ExampDir]);
        false ->
            io:format("\nThere are no examples installed.\n", [])
    end,
    io:format("\nRead the full documentation of Lux (version ~s)"
              " in the browser:"
              "\n\n\t~s\n",
              [version_str(), doc_url(LuxAppDir)]).

doc_url(AppDir) ->
    UsersGuide = filename:join([AppDir, "lux.html"]),
    "file://" ++ filename:absname(UsersGuide).

help(LuxAppDir, Specs, HelpMode) ->
    do_usage(Specs, LuxAppDir, HelpMode),
    0.

version() ->
    io:format("~s\n", [version_str()]),
    0.

version_str() ->
    Mod = lux_utils,
    case code:ensure_loaded(Mod) of
        {module, Mod} -> Mod:version();
        {error, What} -> atom_to_list(What)
    end.

gen_markdown(ToFile) ->
    case lux_debug:gen_markdown(ToFile) of
        ok ->
            0;
        {error, FileReason} ->
            io:format("ERROR: ~s: ~s\n",
                      [ToFile, file:format_error(FileReason)]),
            1
    end.

pre_markdown(LuxAppDir, ToFile) ->
    FromFile = ToFile ++ ".src",
    AbsFileName0 = filename:absname(ToFile),
    AbsFileName = normalize_filename(AbsFileName0),
    RelFileName = drop_prefix(LuxAppDir, AbsFileName),
    RelFileDir = filename:dirname(RelFileName),
    {ok, Cwd} = file:get_cwd(),
    RelWorkDir = drop_prefix(LuxAppDir, Cwd),
    case file:read_file(FromFile) of
        {ok, Bin} ->
            try
                Expand = fun(L, {Files, Lines}) ->
                                 case markdown_line(RelWorkDir, L) of
                                     {keep, Line} ->
                                         {Files, [Line | Lines]};
                                     {expand, InclFile, InclLines} ->
                                         RelInclFile =
                                             relpath(RelFileDir, InclFile),
                                         {[RelInclFile | Files],
                                          [InclLines | Lines]};
                                     {expand, EvalLines} ->
                                         {Files,
                                          [EvalLines | Lines]}
                                 end
                         end,
                Lines = lux_utils:split_lines(Bin),
                {InclFiles, RevNewLines} =
                    lists:foldl(Expand, {[], []}, Lines),
                DepsIoList =
                    [
                     ToFile,
                     ": ",
                     join(" ", [FromFile | lists:reverse(InclFiles)])
                    ],
                DepsFile = ToFile ++ ".d",
                %% Make dependency file
                case file:write_file(DepsFile, DepsIoList) of
                    ok ->
                        ok;
                    {error, FileReason} ->
                        throw({error,
                               "~s: ~s", [DepsFile,
                                          file:format_error(FileReason)]})
                end,
                IoList = lux_utils:expand_lines(lists:reverse(RevNewLines)),
                %% Markdown file
                case file:write_file(ToFile, IoList) of
                    ok ->
                        0;
                    {error, FileReason2} ->
                        throw({error,
                               "~s: ~s", [ToFile,
                                          file:format_error(FileReason2)]})
                end
            catch
                throw:{error, Format, Args} ->
                    io:format("ERROR: ~s: " ++ Format ++ "\n",
                              [FromFile] ++ Args),
                    1
            end;
        {error, FileReason} ->
            io:format("ERROR: ~s: ~s\n",
                      [FromFile, file:format_error(FileReason)]),
            1
    end.

relpath(".", Path) ->
    Path;
relpath(Prefix, Path) ->
    UpDir = filename:join([".." || _ <- filename:split(Prefix)]),
    filename:join([UpDir, Path]).

markdown_line(RelWorkDir, Line) ->
    Incomplete = {error, "Incomplete include statement", []},
    case string:strip(binary_to_list(Line), left) of
        "#include " ++ InclFile ->
            case string:strip(InclFile, both) of
                "<" ->
                    throw(Incomplete);
                "<" ++ InclFile2 ->
                    case lists:reverse(InclFile2) of
                        ">" ++ RevInclFile ->
                            InclFile3 = lists:reverse(RevInclFile),
                            markup_include(InclFile3);
                        _ ->
                            throw(Incomplete)
                    end;
                _ ->
                    throw(Incomplete)
            end;
        "#eval-include " ++ Cmd0 ->
            Cmd = string:strip(Cmd0),
            FullCmd =
                case relpath(RelWorkDir, "") of
                    "" -> Cmd;
                    UpDir  -> "cd " ++ UpDir ++ " && " ++ Cmd
                end,
            io:format("\t~s\n", [FullCmd]),
            {Output, RetCode} = lux_utils:cmd(FullCmd),
            io:format("\techo $?\n\t~s\n", [RetCode]),
            Prompt = ".../lux> ",
            Prefix = ">     ",
            {expand,
             [
              "Evaluate `", Cmd, "`\n\n",
              Prefix, Prompt, Cmd, "\n",
              lux_utils:expand_lines([[Prefix, L] || L <- Output]),
              "\n",
              Prefix, Prompt, "echo $?\n",
              Prefix, RetCode, "\n"
             ]};
        "#eval-silent " ++ Cmd0 ->
            Cmd = string:strip(Cmd0),
            FullCmd =
                case relpath(RelWorkDir, "") of
                    "" -> Cmd;
                    UpDir  -> "cd " ++ UpDir ++ " && " ++ Cmd
                end,
            io:format("\t~s\n", [FullCmd]),
            {_Output, RetCode} = lux_utils:cmd(FullCmd),
            io:format("\techo $?\n\t~s\n", [RetCode]),
            {expand,
             [
              "Evaluate `", Cmd, "`\n"
             ]};
        _ ->
            {keep, Line}
    end.

markup_include(RelFile) ->
    AbsFile = filename:join(["..", RelFile]),
    case file:read_file(AbsFile) of
        {ok, Bin} ->
            Lines = lux_utils:split_lines(binary_to_list(Bin)),
            RelFile2 = filename:join(["...", "lux", RelFile]),
            {expand,
             RelFile,
             [
              "Snippet from the enclosed `", RelFile2, "` file:\n",
              "\n",
              lux_utils:expand_lines([[">     ", L] || L <- Lines])
             ]};
        {error, FileReason} ->
            RelFile2 = filename:join(["..", "lux", RelFile]),
            throw({error, "~s: ~s", [RelFile2, file:format_error(FileReason)]})
    end.

internal_debug(MainOp, Args) ->
    require_app(MainOp, debugger),
    require_app(MainOp, wx),
    Escript = escript:script_name(),
    {ok, [{shebang, Shebang0} | _Rest]} = escript:extract(Escript, []),
    case Shebang0 of
        default -> Shebang = "/usr/bin/env escript";
        Shebang -> ok
    end,
    FlatArgs = lists:flatten([[" ", A] || A <- Args,
                                          A =/= "-D",
                                          A =/= "--internal_debug"]),
    %% Use "escript -d" to enable debugging of this escript. Break at main/1.
    DebugCmd = Shebang ++ " -d " ++ Escript ++ FlatArgs,
    io:format("~s\n", [DebugCmd]),
    PortOpts = [binary, stream, use_stdio, stderr_to_stdout, eof],
    Port = open_port({spawn, DebugCmd}, PortOpts),
    spawn_link(fun() -> forward_stdin(Port, 1) end),
    forward_stdout(Port).

suite_trace(MainOp, LuxAppDir, Opts, OpModes, Specs, OrigArgs) ->
    require_app(MainOp, runtime_tools),
    case add_defaults(Opts) of
        {ok, Opts2} ->
            LogDir = proplists:get_value(log_dir, Opts2),
            TraceFile0 = filename:join([LogDir, "lux_suite"]),
            {ok, TraceFile} = start_suite_trace(TraceFile0),
            io:format("WARNING: Internal tracing of suite started,"
                      " see file ~s\n",
                      [TraceFile]),
            Key = "--suite_trace",
            NewOpts = lists:keyreplace(Key, 1, Opts2, {Key, []}),
            Res = dispatch(NewOpts, LuxAppDir, OpModes, Specs, OrigArgs),
            stop_trace(),
            Res;
        {error, Format, Args} ->
            io:format(Format, Args),
            1
    end.

start_suite_trace(TraceFile) ->
    start_trace(suite, {file, TraceFile}, self()).

start_trace(TraceMode, TraceTarget, FirstTracePid) ->
    TracePids = trace_pids(TraceMode, FirstTracePid),
    TraceFlags = trace_flags(TraceMode),
    TraceMFAs = trace_mfas(TraceMode),
    start_trace(TraceTarget, TracePids, TraceFlags, TraceMFAs).

start_trace(TraceTarget, TracePids, TraceFlags, TraceMFAs) ->
    case dbg:get_tracer() of
        {error, _Reason} ->
            do_start_trace(TraceTarget, TracePids, TraceFlags, TraceMFAs);
        {ok, _Tracer} ->
            {error, already_started}
    end.

uniq_file(Base, Suffix, Count) ->
    File = Base ++ Suffix,
    case file:read_file_info(File) of
        {ok, _FileInfo} ->
            uniq_file(Base, "." ++ integer_to_list(Count), Count+1);
        {error, enoent} ->
            File
    end.

trace_pids(TraceMode, TracePid) ->
    AllNewPids = [P || P <- processes(),
                       P >= TracePid],
    case TraceMode of
        suite  -> [TracePid];
        event  -> AllNewPids;
        'case' -> AllNewPids
    end.

trace_flags(TraceMode) ->
    case TraceMode of
        suite  ->  [c, p];
        event  ->  [c, p, sos];
        'case' ->  [c, p, sos]
    end.

trace_mfas(TraceMode) ->
    LuxAppDir = code:lib_dir(?APPLICATION),
    Mods = modules(LuxAppDir, ?APPLICATION),
    MFAs = [{M, '_', '_'} || M <- Mods],
    case TraceMode of
        suite  -> MFAs;
        event  -> [{lux, trace_me, '_'}];
        'case' -> MFAs
    end.

do_start_trace(TraceTarget, TracePids, TraceFlags0, TraceMFAs) ->
    Res = start_tracer(TraceTarget),
    TraceFlags = [timestamp | TraceFlags0],
    [{ok, _} = dbg:p(P, TraceFlags) || P <- TracePids],
    MatchSpec = [{'_', [], [{exception_trace}]}],
    [{ok, _} = dbg:tpl(MFA, MatchSpec) || MFA <- TraceMFAs],
    Res.

start_tracer(TraceTarget) ->
    case TraceTarget of
        {file, TraceFile} ->
            TraceFile2 = uniq_file(TraceFile, "", 2),
            WrapFilesSpec =
                {TraceFile2 ++ ".", wrap, ".etrace", 16*1024*1024, 8},
            TracePort = dbg:trace_port(file, WrapFilesSpec),
            {ok, _} = dbg:tracer(port, TracePort),
            {ok, TraceFile2};
        {log, HandlerFun, HandlerInit} ->
            HandlerSpec = {HandlerFun, HandlerInit},
            {ok, _} = dbg:tracer(process, HandlerSpec),
            {ok, log}
    end.

stop_trace() ->
    dbg:flush_trace_port(),
    dbg:stop_clear().

modules(AppDir, App) ->
    AppStr = atom_to_list(App),
    AppFile = filename:join([AppDir, "ebin", AppStr++".app"]),
    case file:consult(AppFile) of
        {ok, [{application, App, Spec}]} ->
            {_, AppMods} = lists:keyfind(modules, 1, Spec),
            [?MODULE | AppMods];
        {ok, _} ->
            io:format("WARNING: ~s: Bad file format\n", [AppFile]),
            ['_'];
        {error, Reason} ->
            io:format("WARNING: ~s: ~s\n",
                      [AppFile, file:format_error(Reason)]),
            ['_']
    end.

display_trace(LuxAppDir, TraceFile, Opts) ->
    FilterFile = filter_trace_file(LuxAppDir, Opts),
    lux_trace:display(TraceFile, FilterFile).

filter_trace_file(LuxAppDir, Opts) ->
    case lists:keyfind("--filter_trace", 1, Opts) of
        {_, []} ->
            filename:join([LuxAppDir, "priv", "filter_trace"]);
        {_, FilterFile} ->
            lists:last(FilterFile)
    end.

event_trace(MainOp, LuxAppDir, Opts, OpModes, Specs, OrigArgs) ->
    require_app(MainOp, runtime_tools),
    require_app(MainOp, et),
    require_app(MainOp, wx),
    EtOpts =
        [
         {title,"LUX"},
         {trace_global,true},
         {trace_pattern,{lux,max}},
         {hide_unknown, true},
         {max_actors,10}
        ],
    case et_viewer:start(EtOpts) of
        {ok, ViewerPid} ->
            ViewerRef = erlang:monitor(process, ViewerPid),
            Key = "--event_trace",
            NewOpts = lists:keyreplace(Key, 1, Opts, {Key, []}),
            dispatch(NewOpts, LuxAppDir, OpModes, Specs, OrigArgs),
            receive
                {'DOWN', ViewerRef, _Type, _Object, shutdown} ->
                    ok;
                {'DOWN', ViewerRef, _Type, _Object, Reason} ->
                    io:format("Event tracer exit: ~p\n", [Reason])
            end,
            0;
        {error, Reason} ->
            io:format("Event tracer error: ~p\n", [Reason]),
            1
    end.

forward_stdin(Port, N) ->
    case io:get_line("") of
        eof when N =:= 1 ->
            %% Closed already at startup
            exit(normal);
        eof ->
            io:format("\nEOF: stdin closed\n", []),
            exit(normal);
        {error,terminated} ->
            exit(normal);
        Data ->
            %% forward to port
            true = port_command(Port, Data),
            forward_stdin(Port, N+2)
    end.

forward_stdout(Port) ->
    receive
        {Port, {data, Data}} ->
            io:format("~s", [Data]),
            forward_stdout(Port);
        {Port, eof} ->
            port_close(Port),
            0;
        Unexpected ->
            io:format("Got something unexpected from port: ~p\n",
                      [Unexpected]),
            forward_stdout(Port)
    end.

make(MainOp) ->
    io:format("Making ~p...\n", [?APPLICATION]),
    require_app(MainOp, tools),
    {ok, LuxAppDir} = file:get_cwd(),
    SrcDir = filename:join([LuxAppDir, "src"]),
    EbinDir = filename:join([LuxAppDir, "ebin"]),
    {ok, SrcDir} = {file:set_cwd(SrcDir), SrcDir},
    {up_to_date, EbinDir} = {make:all([debug_info,{outdir, EbinDir}]), EbinDir},
    AppStr = atom_to_list(?APPLICATION),
    SrcAppFile = filename:join([SrcDir, AppStr ++ ".app.src"]),
    DestAppFile = filename:join([EbinDir, AppStr ++ ".app"]),
    io:format("Copy: ~s\n", [filename:basename(DestAppFile)]),
    {{ok, _}, SrcAppFile, DestAppFile} =
        {file:copy(SrcAppFile, DestAppFile), SrcAppFile, DestAppFile},
    ok = file:set_cwd(LuxAppDir),
    c_compile("gcc -o priv/bin/runpty -g -O2 -Wall c_src/runpty.c").

c_compile(Cmd) ->
    io:format("Compile: ~s\n", [Cmd]),
    {Output, Status} = cmd(Cmd),
    io:format("~s\n", [Output]),
    case Status of
        0 -> 0;
        _ -> 1
    end.

cmd(Cmd) ->
    Output = os:cmd(Cmd++"; echo $?"),
    Tokens = string:tokens(Output, "\n"),
    [CmdStatus | Rest] = lists:reverse(Tokens),
    {lists:reverse(Rest), CmdStatus}.

install(MainOp, LuxAppDir, InstallDir, Opts) ->
    InstallProf = reltool_profile(Opts),
    io:format("Installing ~p as a ~p system... ~s\n",
              [?APPLICATION, InstallProf, InstallDir]),
    {RootDir, ReltoolOpts} = reltool_opts(MainOp, LuxAppDir, Opts),
    case reltool:start_server(ReltoolOpts) of
        {ok, ServerPid} ->
            case reltool:get_status(ServerPid) of
                {ok, Warnings} ->
                    [io:format("WARNING: ~s\n", [W]) || W <- Warnings],
                    do_install(ServerPid, InstallDir, RootDir);
                {error, StatusReasonStr} ->
                    io:format("ERROR: ~s\n", [StatusReasonStr]),
                    1
            end;
        {error, StartReasonStr} ->
            io:format("ERROR: ~s\n", [StartReasonStr]),
            1
    end.

do_install(ServerPid, InstallDir, RootDir) ->
    GetSpecRes = reltool:get_target_spec(ServerPid),
    _StopRes = reltool:stop(ServerPid),
    case GetSpecRes of
        {ok, Spec} ->
            case InstallDir of
                "" ->
                    io:format("Spec: ~p.\n", [Spec]),
                    timer:sleep(timer:seconds(1)),
                    0;
                _ ->
                    case reltool:eval_target_spec(Spec,
                                                  RootDir,
                                                  InstallDir) of
                        ok ->
                            0;
                        {error, EvalReasonStr} ->
                            io:format("ERROR: ~s\n", [EvalReasonStr]),
                            1
                    end
            end;
        {error, SpecReasonStr} ->
            io:format("ERROR: ~s\n", [SpecReasonStr]),
            1
    end.

reltool(MainOp, LuxAppDir, Opts) ->
    io:format("Starting reltool...\n", []),
    process_flag(trap_exit, true),
    {_RootDir, ReltoolOpts} = reltool_opts(MainOp, LuxAppDir, Opts),
    case reltool:start(ReltoolOpts) of
        {ok, Pid} ->
            link(Pid),
            receive
                {'EXIT', Pid, Reason} ->
                    io:format("reltool exit: ~p\n", [Reason])
            end,
            0;
        {error, ReasonStr} ->
            io:format("ERROR: ~s\n", [ReasonStr]),
            1
    end.

reltool_opts(MainOp, LuxAppDir, Opts) ->
    require_app(MainOp, reltool),
    {IsCross, RootDir} = root_dir(Opts),
    ThisEscript = escript:script_name(),
    %% Include some extra files beside the default files
    AppFilters =
        [{incl_app_filters, ["^LICENSE", "^lux.html",
                             "ebin", "^priv", "^examples.*", "^emacs.*"]},
         {excl_archive_filters, ["^LICENSE", "^lux.html",
                                 "^priv", "^examples.*", "^emacs.*"]},
         {excl_app_filters, [".*empty$"]}],
    HasAppLibDir = app_has_feature(MainOp, reltool, "0.6", mandatory),
    LuxApps =
        case HasAppLibDir of
            true ->
                %% New reltool can handle lib_dir in app
                [{app, ?APPLICATION, [{lib_dir, LuxAppDir} | AppFilters]}];
            false ->
                %% Old reltool
                [{app, ?APPLICATION, AppFilters},
                 {lib_dirs, [filename:dirname(LuxAppDir)]}]
        end,
    HasRelaxedExclusion = app_has_feature(MainOp, reltool, "0.6.4", mandatory),
    {AppCondsWx, AppCondsCross} =
        case {IsCross, HasRelaxedExclusion} of
            {true, false} ->
                {[],
                 []};
            _ ->
                %% New reltool can handle excluded non-existent apps
                {[{wx, exclude}],
                 [{hipe, exclude}, {reltool, exclude}]}
        end,
    AppCondsCommon = [{erts, include}, {crypto, exclude}, {tools, exclude}],
    AppConds = AppCondsCommon ++ AppCondsCross ++ AppCondsWx,
    {_, InstallApps} = lists:keyfind("--install_app", 1, Opts),
    InstallApps2 = [{list_to_atom(A), include} || A <- InstallApps],
    AppConds2 = [{A, C} || {A, C} <- AppConds,
                           not lists:keymember(A, 1, InstallApps2)],
    AppConds3 = AppConds2 ++ InstallApps2,
    ExtraApps = filter_apps(MainOp, AppConds3, IsCross, HasRelaxedExclusion),
    Common =
        [{root_dir, RootDir},
         {debug_info, strip},
         {escript, ThisEscript, [{incl_cond, include}]}],
    Profile =
        case reltool_profile(Opts) of
            standalone ->
                [{profile, standalone},
                 {excl_sys_filters,
                  {add,
                   ["^bin/(epmd|start.boot)(|\\.exe)" ++ [$$],
                    "^erts.*/bin/(epmd|heart|ct_run)(|\\.exe)"  ++ [$$]]}}];
            InstallProf ->
                [{profile, InstallProf}]
        end,
    {RootDir, [{sys, Common ++ LuxApps ++ ExtraApps ++ Profile}]}.

reltool_profile(Opts) ->
    case lists:keyfind("--install_profile", 1, Opts) of
        {_, []}      -> standalone;
        {_, Profile} -> lists:last(Profile)
    end.

app_has_feature(MainOp, AppName, LowestVersion, Require) ->
    LoadedApps = application:loaded_applications(),
    case lists:keyfind(AppName, 1, LoadedApps) of
        {_Name, _Slogan, Version} when Version >= LowestVersion ->
            true;
        {_Name, _Slogan, _Version} ->
            false;
        false when Require =:= optional ->
            false;
        false when Require =:= mandatory ->
            require_app(MainOp, AppName), % Halt upon failure
            app_has_feature(MainOp, AppName, LowestVersion, Require)
    end.

filter_apps(_MainOp, AppConds, _IsCross, true) ->
    [{app, AppName, [{incl_cond,InclCond}]} || {AppName,InclCond} <- AppConds];
filter_apps(MainOp, AppConds, _IsCross, false) ->
    lists:zf(fun({AppName, InclCond}) ->
                     case application:load(AppName) of
                         ok ->
                             {true, {app, AppName, [{incl_cond, InclCond}]}};
                         {error, {already_loaded,AppName}}->
                             {true, {app, AppName, [{incl_cond, InclCond}]}};
                         {error, _} when InclCond =:= include ->
                             missing_app(MainOp, AppName);
                         {error, _} ->
                             false
                     end
             end,
             AppConds).

root_dir(Opts) ->
    case lists:keyfind("--root_dir", 1, Opts) of
        {_, []}        -> {false, code:root_dir()};
        {_, [RootDir]} -> {true, RootDir}
    end.

xref(MainOp, LuxAppDir, Opts) ->
    process_flag(trap_exit, true),
    require_app(MainOp, tools),
    {_RootDir, ReltoolOpts} = reltool_opts(MainOp, LuxAppDir, Opts),
    case reltool:start_server(ReltoolOpts) of
        {ok, ServerPid} ->
            case reltool:get_status(ServerPid) of
                {ok, _Warnings} ->
                    %% [io:format("WARNING: ~s\n", [W]) || W <- Warnings],
                    {ok, {sys, Sys}} =
                        reltool:get_config(ServerPid, true, true),
                    _StopRes = reltool:stop(ServerPid),
                    try
                        do_xref(Sys)
                    catch
                        _Class:Reason ->
                            io:format("XREF LUX ERROR: ~p\n", [Reason]),
                            1
                    end;
                {error, StatusReasonStr} ->
                    io:format("XREF LUX ERROR: ~s\n", [StatusReasonStr]),
                    1
            end;
        {error, StartReasonStr} ->
            io:format("XREF LUX ERROR: ~s\n", [StartReasonStr]),
            1
    end.

do_xref(Sys) ->
    {_, ErtsApps} = lists:keyfind(erts, 1, Sys),
    ExtendedSys = Sys ++ ErtsApps,
    AppEbins =  [{A, filename:join([D, "ebin"])} ||
                    {app, A, O}  <- ExtendedSys,
                    {lib_dir, D} <- O],
    Fun = fun(A, M) ->
                  {_, Ebin} = lists:keyfind(A, 1, AppEbins),
                  {A, M, filename:join([Ebin, atom_to_list(M) ++ ".beam"])}
          end,
    ModFiles =  [Fun(A, M) || {app, A, O} <- ExtendedSys,
                              {mod, M, _} <- O],
    Xref = ?MODULE,
    {ok, _} = xref:start(Xref),
    %% ok = xref:set_library_path(Xref, LibDirs),
    Defaults = [{warnings,false}, {verbose,false}, {builtins,true}],
    ok = xref:set_default(Xref, Defaults),
    {ok, Cwd} = file:get_cwd(),
    Add = fun({_App, _Mod, AbsFile}, Acc) ->
                  RelFile = drop_prefix(Cwd, AbsFile),
                  case xref:add_module(Xref, RelFile) of
                      {ok, _} ->
                          Acc;
                      {error, Callback, Error} ->
                          Chars = lists:flatten(Callback:format_error(Error)),
                          Reason = [C || C <- Chars, C =/= $" ],
                          io:format("ERROR: ~s", [Reason]),
                          1
                  end
          end,
    ExitCode = 0,
    {ExitCode2, EscriptModFile} = xref_add_escript(Sys, Add, ExitCode),
    ExitCode3 = lists:foldl(Add, ExitCode2, ModFiles),
    ModFiles2 = [EscriptModFile | ModFiles],
    ExitCode4 = undefined_function_calls(Xref, ModFiles2, ExitCode3),
    xref:stop(Xref),
    ExitCode4.

xref_add_escript(Sys, Add, ExitCode) ->
    {_, EscriptFile, _} = lists:keyfind(escript, 1, Sys),
    {ok, Sections} = escript:extract(EscriptFile, [compile_source]),
    {_, EscriptBeam} = lists:keyfind(source, 1, Sections),
    TmpEscriptFile = EscriptFile ++ ".beam",
    EscriptModFile = {?APPLICATION, ?MODULE, TmpEscriptFile},
    case file:write_file(TmpEscriptFile, EscriptBeam) of
        ok ->
            Res = Add(EscriptModFile, ExitCode),
            file:delete(TmpEscriptFile),
            {Res, EscriptModFile};
        {error, FileReason} ->
            io:format("ERROR: ~s ~s\n",
                      [TmpEscriptFile, file:format_error(FileReason)]),
            {1, EscriptModFile}
    end.

undefined_function_calls(Xref, ModFiles, ExitCode) ->
    {ok, MFAs} = xref:analyze(Xref, undefined_function_calls),
    Fun =
        fun({FromMFA, ToMFA}, Acc) ->
                case ignore_call(FromMFA, ToMFA, ModFiles) of
                    true ->
                        Acc;
                    false ->
                        io:format("ERROR: ~s calls undefined function ~s\n",
                                  [mfa(FromMFA), mfa(ToMFA)]),
                        1
                end
        end,
    lists:foldl(Fun, ExitCode, MFAs).

ignore_call(FromMFA, ToMFA, ModFiles) ->
    FromMod = element(1, FromMFA),
    FromApp = which_app(FromMod, ModFiles),
    if
        FromMod =:= ?MODULE ->
            ToMod = element(1, ToMFA),
            lists:member(ToMod, [make, reltool, xref]);
        FromApp =:= ?APPLICATION ->
            false;
        true ->
            true
    end.

which_app(Mod, ModFiles) ->
    {App, _, _} = lists:keyfind(Mod, 2, ModFiles),
    App.

mfa({M, F, A}) ->
  io_lib:format("~s:~s/~p", [M, F, A]).

annotate(LogFile0, Opts) ->
    {_Files, Opts2} = translate_opts(Opts),
    LogFile = filename:absname(LogFile0),
    io:format("Annotating logs ~s...", [LogFile]),
    case lux_suite:annotate_log(true, LogFile, Opts2) of
        ok ->
            io:format("...ok\n", []),
            io:format("\nfile://~s\n", [LogFile ++ ".html"]),
            0;
        {error, File, ReasonStr} ->
            io:format("...ERROR\n\t~p: ~s\n", [File, ReasonStr]),
            1
    end.

history(RelLogDir, Opts) ->
    {Files0, Opts2} = translate_opts(Opts),
    case Files0 of
        []    -> Files = [RelLogDir];
        Files -> ok
    end,
    RelHtmlFile = filename:join([RelLogDir, "lux_history.html"]),
    AbsHtmlFile = filename:absname(RelHtmlFile),
    case safe_history(Files, RelHtmlFile, Opts2) of
        ok ->
            io:format("...ok\n", []),
            io:format("\nfile://~s\n", [AbsHtmlFile]),
            0;
        {error, File, ReasonStr} ->
            io:format("...ERROR\n\t~s: ~s\n", [File, ReasonStr]),
            1
    end.

safe_history(LogDirs, HtmlFile, Opts) ->
    case lux_html_history:generate(LogDirs, HtmlFile, Opts) of
        {ok, HtmlFile} ->
            lux_html_parse:validate_html(HtmlFile, Opts);
        {error, File, Reason} ->
            {error, File, Reason}
    end.

run(Opts, Files, PrevLogDir, OrigArgs) ->
    case do_run(Files, Opts, PrevLogDir, OrigArgs) of
        ok -> % HTML
            Summary = success,
            ok;
        {ok, Summary, _SummaryLog, _Results} -> % LUX
            ok;
        {error, undefined, no_input_files} ->
            Summary = error;
        {error, File, ReasonBin} ->
            io:format("\n\nFATAL ERROR: ~s:\n\t~s\n", [File, ReasonBin]),
            Summary = error
    end,
    exit_code(Summary).

do_run(Files, Opts, PrevLogDir, OrigArgs) ->
    case is_html(Files) of
        true ->
            lux_html_parse:validate_html(hd(Files), Opts);
        false ->
            ThisEscript = escript:script_name(),
            lux_suite:run(Files, Opts, PrevLogDir, [ThisEscript | OrigArgs])
    end.

is_html(Files) ->
    lists:any(fun(F) -> lists:suffix(".html", F) end, Files).

exit_code(Summary) ->
    case Summary of
        success -> 0;
        skip    -> 0;
        warning -> 0;
        fail    -> 1;
        error   -> 1
    end.

translate_opts([
     {?FILES,                 Files},
     {"--help",               _Help},
     {"--version",            _Version},
     {"--gen_markdown",       _GenMarkdown},
     {"--pre_markdown",       _PreMarkdown},
     {"--internal_debug",     _InternalDebug},
     {"--event_trace",        _EventTrace},
     {"--suite_trace",        _SuiteTrace},
     {"--display_trace",      _DisplayTrace},
     {"--filter_trace",       _FilterTrace},
     {"--install",            _InstallDir},
     {"--install_app",        _InstallApp},
     {"--install_profile",    _InstallProfile},
     {"--reltool",            _Reltool},
     {"--xref",               _Xref},
     {"--annotate",           _LogFile},
     {"--history",            _LogDir},
     {"--rerun",              ReRun},
     {"--html",               Html},
     {"--debug",              Debug},
     {"--debug_file",         DebugFile},
     {"--skip",               Skip},
     {"--skip_unless",        SkipUnless},
     {"--skip_unstable",      SkipUnstable},
     {"--skip_skip",          SkipSkip},
     {"--require",            Require},
     {"--case_prefix",        CasePrefix},
     {"--log_dir",            LogDir},
     {"--config_dir",         ConfigDir},
     {"--config_name",        ConfigName},
     {"--suite",              Suite},
     {"--run",                Run},
     {"--extend_run",         ExtendRun},
     {"--revision",           Revision},
     {"--hostname",           Hostname},
     {"--mode",               Mode},
     {"--doc",                Doc},
     {"--progress",           Progress},
     {"--multiplier",         Multiplier},
     {"--suite_timeout",      SuiteTimeout},
     {"--case_timeout",       CaseTimeout},
     {"--flush_timeout",      FlushTimeout},
     {"--poll_timeout",       PollTimeout},
     {"--timeout",            ExpectTimeout},
     {"--cleanup_timeout",    CleanupTimeout},
     {"--newshell",           NewShell},
     {"--shell_wrapper",      ShellWrapper},
     {"--shell_cmd",          ShellCmd},
     {"--shell_args",         ShellArgs},
     {"--shell_prompt_cmd",   ShellPromptCmd},
     {"--shell_prompt_regexp",ShellPromptRegexp},
     {"--post_cleanup_cmd",   PostCleanupCmd},
     {"--file_pattern",       FilePattern},
     {"--root_dir",           _RootDir},
     {"--var",                Var},
     {"--tap",                Tap},
     {"--junit",              Junit}
    ]) ->
    Mode2 =
        if
            Doc =/= [] -> [doc];
            true       -> Mode
        end,
    Opts =
        [
         {debug,              Debug},
         {debug_file,         DebugFile},
         {progress,           Progress},
         {rerun,              ReRun},
         {html,               Html},
         {case_timeout,       CaseTimeout},
         {flush_timeout,      FlushTimeout},
         {poll_timeout,       PollTimeout},
         {timeout,            ExpectTimeout},
         {cleanup_timeout,    CleanupTimeout},
         {newshell,           NewShell},
         {shell_wrapper,      ShellWrapper},
         {shell_cmd,          ShellCmd},
         {shell_args,         ShellArgs},
         {shell_prompt_cmd,   ShellPromptCmd},
         {shell_prompt_regexp,ShellPromptRegexp},
         {post_cleanup_cmd,   PostCleanupCmd},
         {multiplier,         Multiplier},
         {suite_timeout,      SuiteTimeout},
         {log_dir,            LogDir},
         {skip,               Skip},
         {skip_unless,        SkipUnless},
         {skip_unstable,      SkipUnstable},
         {skip_skip,          SkipSkip},
         {require,            Require},
         {case_prefix,        CasePrefix},
         {var,                Var},
         {mode,               Mode2},
         {doc,                Doc},
         {config_dir,         ConfigDir},
         {config_name,        ConfigName},
         {suite,              Suite},
         {run,                Run},
         {extend_run,         ExtendRun},
         {revision,           Revision},
         {hostname,           Hostname},
         {file_pattern,       FilePattern},
         {tap,                Tap},
         {junit,              Junit}
        ],
    {Files, lux_suite:args_to_opts(Opts, suite_style, [])}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Generic option handling
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

-type opt()      :: string() .
-type name()     :: string().
-type default()  :: term().
-type type()     :: string | binary |
                    atom | existing_atom |
                    integer | {integer, min(), max()} |
                    float | {float, min(), max()} |
                    boolean | validate().
-type min()      :: integer().
-type max()      :: integer() | infinity.
-type validate() :: fun((opt() | default()) -> val()).
-type presence() :: none | optional | mandatory.
-type spec()     :: {name(), [opt()]} | % alias
                    {name(), default(), type(), presence()}.
-type val()      :: term().
-spec getopts([opt()], [spec()], string()) -> [[val()]].

%% Parse options and validate their values.
%% All options in the specs are returned and they keep that order.
getopts(Args, Specs, LuxAppDir) ->
    try
        Opts = do_getopts(Args, Specs, []),
        expand_opts(Opts, Specs)
    catch
        throw:{badarg, Bad} ->
            io:format("~s: ~p is an illegal argument.\n\n",
                      [script_base_name(), Bad]),
            safe_halt(usage(Specs, LuxAppDir));
        throw:{badarg, Bad, Type} ->
            io:format("~s: ~p is an illegal argument. ~p expected.\n\n",
                      [script_base_name(), Bad, Type]),
            safe_halt(usage(Specs, LuxAppDir));
        throw:{badarg, Name, Bad, Type} ->
            io:format("~s: ~p is an illegal value of argument ~s."
                      " ~p expected.\n\n",
                      [script_base_name(), Bad, Name, Type]),
            safe_halt(usage(Specs, LuxAppDir))
    end.

do_getopts([], _Specs, Acc) ->
    lists:reverse(Acc);
do_getopts(Args, Specs, Acc) ->
    {MoreArgs, Name, Val, Type, Presence} = getopt(Args, Specs),
    Val2 = validate(Name, Val, Type, Presence),
    do_getopts(MoreArgs, Specs, [{Name, Val2} | Acc]).

getopt([?FILES | Args], _Specs) ->
    {[], ?FILES, Args, string, optional};
getopt([Arg | Args], Specs) when hd(Arg) =:= $- ->
    {Val, Spec} = find_spec(Arg, Specs),
    case Spec of
        {_Short, Long} ->
            getopt(Long ++ Args, Specs);
        {Name, Default, Type, Presence} ->
            case {Presence, Val, Args} of
                {none, undefined, _} when Type =:= boolean ->
                    %% boolean - no value, return opposite of default
                    {Args, Name, not Default, Type, Presence};
                {none, "true", _} when Type =:= boolean ->
                    %% boolean - got name=true
                    {Args, Name, true, Type, Presence};
                {none, "false", _} when Type =:= boolean ->
                    %% boolean - got name=false
                    {Args, Name, false, Type, Presence};
                {none, _, _} ->
                    %% boolean - got -name=val
                    badarg(Arg, Type);
                {mandatory, undefined, []} ->
                    %% val required - no more options
                    badarg(Arg, Type);
                {mandatory, undefined, ["-" ++ _NextArg | _NextArgs]} ->
                    %% val required - next option is not a val
                    badarg(Arg, Type);
                {mandatory, undefined, [NextVal | NextArgs]} ->
                    %% val required - return separate val
                    {NextArgs, Name, NextVal, Type, Presence};
                {mandatory, _, _} ->
                    %% val required - got name=val
                    {Args, Name, Val, Type, Presence};
                {optional, undefined, []} ->
                    %% optional val - return default val
                    {Args, Name, Default, Type, Presence};
                {optional, undefined, ["-" ++ _NextArg | _NextArgs]} ->
                    %% optional val - return default val
                    {Args, Name, Default, Type, Presence};
                {optional, undefined, [NextVal | NextArgs]} ->
                    %% optional val - got name=val
                    {NextArgs, Name, NextVal, Type, Presence};
                {optional, _, _} ->
                    %% optional val - return default val
                    {Args, Name, Val, Type, Presence}
            end
    end;
getopt(Args, _Specs) ->
    {[], ?FILES, Args, string, optional}.

expand_opts(Opts, Specs) ->
    Fun = fun({_Short, _Long}, Acc) -> % alias
                  Acc;
             ({Name, _Default, _Type, _Presence}, Acc) ->
                  Vals = proplists:get_all_values(Name, Opts),
                  Vals2 =
                      if
                          Name =:= ?FILES ->
                              lists:append(Vals);
                          true ->
                              Vals
                      end,
                     [{Name, Vals2} | Acc]
          end,
    lists:reverse(lists:foldl(Fun, [], Specs)).

validate(Name, Val, Type, Presence) ->
    try
        case Type of
            string when is_list(Val) ->
                Val;
            binary ->
                list_to_binary(Val);
            atom ->
                list_to_atom(Val);
            existing_atom ->
                list_to_existing_atom(Val);
            integer ->
                list_to_integer(Val);
            {integer, _Min, infinity} when Val =:= "infinity" ->
                infinity;
            {integer, Min, infinity} when Val >= Min ->
                list_to_integer(Val);
            {integer, Min, Max} when Val >= Min, Val =< Max ->
                list_to_integer(Val);
            float ->
                list_to_float(Val);
            {float, _Min, infinity} when Val =:= "infinity" ->
                infinity;
            {float, Min, infinity} when Val >= Min ->
                list_to_float(Val);
            {float, Min, Max} when Val >= Min, Val =< Max ->
                list_to_float(Val);
            boolean when Val =:= true; Val =:= "true" ->
                true;
            boolean when Val =:= false; Val =:= "false" ->
                false;
            {enum, Enum} ->
                enum_value(Enum, Val);
            _ when Val =:= undefined, Presence =/= mandatory ->
                Val
        end
    catch
        _Class:_Reason ->
            badarg(Name, Val, Type)
    end.

find_spec(Opt, Specs) ->
    {Name, Val} =
        case lists:prefix("--", Opt) of
            true ->
                %% --name=val
                Eq = $=,
                case lists:splitwith(fun(Char) -> Char =/= Eq end, Opt) of
                    {N, [Eq | V]} -> {N, V};
                    {N, []}       -> {N, undefined}
                end;
            false ->
                {Opt, undefined}
        end,
    %% io:format("Option ~p: ~p -> ~p\n~p\n", [Opt, Name, Val, Specs]),
    case lists:keyfind(Name, 1, Specs) of
        false -> badarg(Opt);
        Spec  -> {Val, Spec}
    end.

badarg(Val) ->
    do_throw({badarg, Val}).

badarg(Val, {enum, Enum}) ->
    do_throw({badarg, Val, enum_usage(Enum)});
badarg(Val, Type) ->
    do_throw({badarg, Val, Type}).

badarg(Name, Val, {enum, Enum}) ->
    do_throw({badarg, Name, Val, enum_usage(Enum)});
badarg(Name, Val, Type) ->
    do_throw({badarg, Name, Val, Type}).

do_throw(Reason) ->
    throw(Reason).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Generic application handling
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

fatal_error(RetCode, Format, Args) ->
    io:format("\nFATAL ERROR : " ++ Format, Args),
    display_app_info(),
    safe_halt(RetCode).

display_app_info() ->
    {ok, Cwd} = file:get_cwd(),
    ThisEscript = escript:script_name(),
    io:format("ESCRIPT     : ~s\n", [ThisEscript]),
    io:format("VERSION     : ~s\n", [version_str()]),
    io:format("CWD         : ~s\n", [Cwd]),
    io:format("APP DIR     : ~s\n", [code:lib_dir(?APPLICATION)]),
    io:format("ROOT DIR    : ~s\n", [code:root_dir()]),
    io:format("CODE PATH   : ~p\n", [code:get_path()]).

safe_halt(RetCode) ->
    error_logger:tty(false),

    Ports = erlang:ports(),
    Timeout = timer:seconds(10),
    CloseStderr =
        fun(P, RC) -> safe_port_close(P, name, "2/2", RC, Timeout) end,
    TmpRetCode = lists:foldl(CloseStderr, RetCode, Ports),

    User = whereis(user),
    CloseStdout =
        fun(P, RC) -> safe_port_close(P, connected, User, RC, Timeout) end,
    SafeRetCode = lists:foldl(CloseStdout, TmpRetCode, Ports),

    if SafeRetCode =:= 0 -> ok; true -> timer:sleep(500) end,

    try
        erlang:halt(SafeRetCode, [{flush,false}]) % Introduced in OTP R16
    catch
        error:badarg ->
            erlang:halt(SafeRetCode) % May hang in some older OTP releases...
    end.

safe_port_close(Port, Item, Val, RetCode, Timeout) ->
    case erlang:port_info(Port, Item) of
        {Item, Val} ->
            erlang:port_connect(Port, self()),
            Port ! {self(), close},
            receive
                {Port, closed} ->
                    RetCode
            after Timeout ->
                    5
            end;
        _ ->
            RetCode
    end.

require_app(MainOp, AppName) ->
    case code:lib_dir(AppName) of
        {error, _Reason} ->
            missing_app(MainOp, AppName);
        AppDir ->
            case application:load(AppName) of
                ok ->
                    AppDir;
                {error, {already_loaded,AppName}}->
                    AppDir;
                {error, _} ->
                    missing_app(MainOp, AppName)
            end
    end.

missing_app(undefined, AppName) ->
    fatal_error(4, "The application '~p' is missing.\n", [AppName]);
missing_app(MainOp, AppName) ->
    fatal_error(4,
                "The application '~p' is required for the ~p option.\n",
                [AppName, MainOp]).

ensure_lux_app_dir(Retry) ->
    AppName = ?APPLICATION,
    case code:lib_dir(AppName, ebin) of
        {error, _Reason} when Retry =:= true ->
            %% Add application ebin to the code path and see if it works
            ThisEscript = resolve_path(escript:script_name()),
            TopDir = filename:dirname(filename:dirname(ThisEscript)),
            case filename:extension(ThisEscript) of
                ".escript" ->
                    %% Standalone installation
                    Wildcard = filename:join([TopDir, "lib", "lux*"]),
                    case lists:sort(filelib:wildcard(Wildcard)) of
                        [] ->
                            AppDir = TopDir;
                        [AppDir | _] ->
                            ok
                    end;
                _ ->
                    %% Development
                    AppDir = TopDir
            end,
            BaseDir = filename:basename(AppDir),
            case lists:prefix("lux-", BaseDir) of
                true ->
                    ok;
                false when BaseDir =:= "lux" ->
                    ok;
                false ->
                    fatal_error(2, "Application directory not named lux: ~p\n",
                                [AppDir])
            end,
            EbinDir = filename:join([AppDir, "ebin"]),
            %% io:format("~s: Add directory ~p to code path\n",
            %%           [AppName, EbinDir]),
            case code:add_patha(EbinDir) of
                true ->
                    ok;
                {error, AddReason} ->
                    io:format("ADD PATH FAILED: ~s ~p\n", [EbinDir, AddReason])
            end,
            ensure_lux_app_dir(false);
        {error, bad_name} ->
            fatal_error(2, "The mandatory application '~p' is missing\n",
                        [AppName]);
        {error, Reason} ->
            fatal_error(2, "The mandatory application '~p' is missing: ~p\n",
                        [AppName, Reason]);
        EbinDir ->
            filename:dirname(EbinDir)
    end.

script_base_name() ->
    filename:basename(escript:script_name()).

resolve_path(Path0) ->
    Path = normalize_path(Path0),
    do_resolve_path(filename:split(Path), []).

do_resolve_path([H | T], ResolvedPath) ->
    ResolvedPath2 = case ResolvedPath of
                        [] -> filename:absname(H);
                        _  -> filename:join([ResolvedPath, H])
                    end,
    case file:read_link(ResolvedPath2) of
        {error, _} -> % Normal file
            do_resolve_path(T, ResolvedPath2);
        {ok, Link} -> % Symbolic Link
            ResolvedPath3 =
                filename:absname(filename:join([ResolvedPath, Link])),
            resolve_path(filename:join([ResolvedPath3] ++ T))
    end;
do_resolve_path([], ResolvedPath) ->
    ResolvedPath.

normalize_path(File) when is_binary(File) ->
    list_to_binary(normalize_path(binary_to_list(File)));
normalize_path(File) ->
    do_normalize_path(filename:split(filename:absname(File)), []).

do_normalize_path([H | T], Acc) ->
    Acc2 =
        case H of
            "."                  -> Acc;
            ".." when Acc =:= [] -> Acc;
            ".."                 -> tl(Acc);
            _                    -> [H | Acc]
        end,
    do_normalize_path(T, Acc2);
do_normalize_path([], Acc) ->
    filename:join(lists:reverse(Acc)).

join(_Sep, []) ->
    [];
join(Sep, [H|T]) ->
 [H | join2(Sep, T)].

join2(_Sep, []) ->
    [];
join2(Sep, [H | T]) ->
    [Sep , H | join2(Sep, T)].
